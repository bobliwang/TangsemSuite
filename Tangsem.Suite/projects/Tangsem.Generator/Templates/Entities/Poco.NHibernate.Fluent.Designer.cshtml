@* Generator: Template *@
@inherits SingleTableMetadataTemplate
			  
@using System.Linq
@using Tangsem.Generator.Metadata
@using Tangsem.Generator.Settings
@using Tangsem.Generator.Templates;

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Linq;

using FluentNHibernate.Mapping;

namespace @(Configuration.MappingNamespace)
{
	/// <summary>
	/// The mapping configuration for @(TableMetadata.EntityName).
	/// </summary>
	public partial class @(TableMetadata.EntityName)Map : ClassMap<@(TableMetadata.EntityName)>
	{
		/// <summary>
		/// The constructor.
		/// </summary>
		public @(TableMetadata.EntityName)Map()
		{
			this.Table("@(TableMetadata.Name)");
			
			@if(TableMetadata.IsView)
			{<text>
			this.ReadOnly();
			</text>}

			// primary key mapping
			this.MapId();
			
			// basic columns mapping
			this.MapBasicColumns();
			
      @if (Configuration.GenRelationship) {<text>
      // outgoing references mapping
			this.MapOutgoingReferences();
			
			// incoming references mapping
      this.MapIncomingReferences();
      </text>}
		}
		
		/// <summary>
		/// Map the Primary Key.
		/// </summary>
		private void MapId()
		{
			@if(TableMetadata.PrimaryKeys.Any())
			{<text>
			this.Id(x => x.@(TableMetadata.PrimaryKeys[0].PropertyName))
				.Column("@(TableMetadata.PrimaryKeys[0].ColumnName)")
				.GeneratedBy
				.Native();
			</text>}
			else
			{<text>
			this.Id(x => x.@(TableMetadata.Columns[0].PropertyName))
				.Column("@(TableMetadata.Columns[0].ColumnName)");	
			</text>}
		  
		}
		
		/// <summary>
		/// Map the Basic Columns.
		/// </summary>
		private void MapBasicColumns()
		{
			@foreach (var col in @TableMetadata.Columns.Where(c => (!c.IsOutgoingRefKey || !Configuration.GenRelationship ) && !c.IsPrimaryKey))
			{<text>
			this.Map(x => x.@(col.PropertyName))
                .Column("@(col.ColumnName)")@if (col.Nullable) {<text>;</text>}else{<text>.Not.Nullable();</text>}
			</text>}

		}

    @if (Configuration.GenRelationship) {<text>
		
    /// <summary>
		/// Map the Outgoing References.
		/// </summary>
		private void MapOutgoingReferences()
		{
			@foreach (var reference in this.TableMetadata.OutgoingReferences)
			{<text>
			this.References<@(reference.ParentTableMetadata.EntityName)>(x => x.@(reference.ParentPropertyName))
                .Fetch.Join()
                .Column("@(reference.ColumnPairs[0].ChildColumnMetadata.ColumnName)")@if (reference.ColumnPairs[0].ChildColumnMetadata.Nullable){<text>;</text>}else{<text>.Not.Nullable();</text>}
			</text>}

		}
		
		/// <summary>
		/// Map the Incoming References.
		/// </summary>
		private void MapIncomingReferences()
		{
			@foreach (var reference in this.TableMetadata.IncomingReferences)
			{<text>
			this.HasMany<@(reference.ChildTableMetadata.EntityName)>(x => x.@(reference.ChildListPropertyName))
				.KeyColumn("@(reference.ColumnPairs[0].ChildColumnMetadata.ColumnName)")
                .Inverse()
                .LazyLoad()
                .AsBag();
			</text>}

		}
    </text>}
	}
}